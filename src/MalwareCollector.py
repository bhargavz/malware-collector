#!/usr/bin/python3.4

#import ConfigParser
import configparser
import tweepy
import sys
import re
import requests
import urlparse

#Use the somewhat hidden security feature:
#pip install requests[security]

def createAuth(settings_filename='settings.cfg'):
    settingsFilename = settings_filename

    try:
        config = configparser.ConfigParser()
        config.read(settingsFilename)
        consumer_key = config.get('twitter', 'consumer_key')
        consumer_secret_key = config.get('twitter', 'consumer_secret_key')
        access_token = config.get('twitter', 'access_token')
        access_secret_token = config.get('twitter', 'access_secret_token')

    except configparser.NoSectionError:
        sys.stderr.write("Could not open %s\n" % settingsFilename)
        sys.stderr.write("Exiting...\n")
        sys.exit(1)

    #consumer key, consumer secret
    auth = tweepy.OAuthHandler(consumer_key, consumer_secret_key)
    #access token, access token secret
    auth.set_access_token(access_token, access_secret_token)

    return auth
    #returns an API object
    #return tweepy.API(auth)


class TweetHistory(object):
    def __init__(self, config=None, country=None, settings_filename='settings.cfg'):

        if country is None or country == 'brazil':
            self.country = 455819
            self.settingsFilename = settings_filename
            self.__readConfig()
            #consumer key, consumer secret
            self.auth = tweepy.OAuthHandler(self.consumer_key, self.consumer_secret_key)
            #access token, access token secret
            self.auth.set_access_token(self.access_token, self.access_secret_token)
            #not stream
            self.api = tweepy.API(self.auth)
            self.trends = None

    def __readConfig(self):
        try:
            config = configparser.ConfigParser()
            config.read(self.settingsFilename)
            self.consumer_key = config.get('twitter', 'consumer_key')
            self.consumer_secret_key = config.get('twitter', 'consumer_secret_key')
            self.access_token = config.get('twitter', 'access_token')
            self.access_secret_token = config.get('twitter', 'access_secret_token')
        except configparser.NoSectionError:
            sys.stderr.write("Could not open %s\n" % self.settingsFilename)
            sys.stderr.write("Exiting...\n")
            sys.exit(1)

    def printTrends(self):
        self.trends = self.api.trends_place(self.country)

        for trendsList in self.trends:
            for trend in trendsList['trends']:
                print(trend['name'])

    def getTrends(self):
        self.trends = self.api.trends_place(self.country)
        trendsName = []

        for trendsList in self.trends:
            for trend in trendsList['trends']:
                trendsName.append(trend['name'])
                #print(trend['name'])

        return trendsName

    def searchTweets(self, max_tweets=100, query=None):
        if query is None:
            print("Must define \'query\'!")
            sys.exit(1)
        else:
            #for tweet in tweepy.Cursor(api.search, q=('"good book"'), since='2014-09-16', until='2014-09-17').items(5):
            return [status._json for status in tweepy.Cursor(self.api.search, q=query, include_entities=True).items(max_tweets)]


class MalwareStreamListener(tweepy.StreamListener):
    domainDict = {}
    domainFile = open("data/top-1m.csv", "r")
    lines = domainFile.readlines()
    for line in lines:
        line = line.rsplit()
        line = line[0]
        #print(line)
        domainDict[str(line.split(',')[0])] = line.split(',')[1:][0]

    domainFile.close()

    def __init__(self):
        self.api = tweepy.API(createAuth())

        super(tweepy.StreamListener, self).__init__()

    def on_status(self, status):
        #print("Status: ", status.text, "\n")


        data ={}
        data['text'] = status.text
        data['created_at'] = status.created_at
        data['geo'] = status.geo
        data['source'] = status.source

        #urls is a list of lists
        URLList= re.findall(r'http://[a-zA-Z0-9\.\/\?&=_]+', data['text'])
        if URLList: #not empty
            for url in URLList:
                print("---------------")
                print(url)
                try:
                    url = requests.head(url, allow_redirects=True).url
                    if self.searchOnDomains(url):
                        print(str(url), " is on the list => safe!")
                    else:
                        print(str(url), " is not on the list => it can be malicious!")

                except requests.exceptions.ConnectionError:
                    print(" -> it is not shortned!")

    def searchOnDomains(self, url):

        domain = str(urlparse.urljoin(url, "/")[7:-1])
        if domain.startswith("/"):  #http or https
            domain = domain[1:]
        if domain.startswith("www."):
            domain = domain[4:]

        ret = domain in MalwareStreamListener.domainDict.values()
        return ret
if __name__ == "__main__":
    mc = TweetHistory(country="brazil")
    myTrendsList = mc.getTrends()
    myTweets = mc.searchTweets2(query=myTrendsList[0], max_tweets=100)

    for tweets in myTweets:
        print(tweets['text'].encode('utf-8'))






