#!/usr/bin/python3.4

#import ConfigParser
import configparser
import tweepy
import sys
import re
import requests
import urlparse
import pymongo
import urllib3
import requests

urllib3.disable_warnings()

#Use the somewhat hidden security feature:
#pip install requests[security]

def createAuth(settings_filename='settings.cfg'):
    settingsFilename = settings_filename

    try:
        config = configparser.ConfigParser()
        config.read(settingsFilename)
        consumer_key = config.get('twitter', 'consumer_key')
        consumer_secret_key = config.get('twitter', 'consumer_secret_key')
        access_token = config.get('twitter', 'access_token')
        access_secret_token = config.get('twitter', 'access_secret_token')

    except configparser.NoSectionError:
        sys.stderr.write("Could not open %s\n" % settingsFilename)
        sys.stderr.write("Exiting...\n")
        sys.exit(1)

    #consumer key, consumer secret
    auth = tweepy.OAuthHandler(consumer_key, consumer_secret_key)
    #access token, access token secret
    auth.set_access_token(access_token, access_secret_token)

    return auth
    #returns an API object
    #return tweepy.API(auth)


def getTrends(auth, country):
    api = tweepy.API(auth)
    trends = api.trends_place(country)
    trendsName = []

    for trendsList in trends:
        for trend in trendsList['trends']:
            trendsName.append(trend['name'])

    return trendsName

class TweetHistory(object):
    def __init__(self, config=None, country=None, settings_filename='settings.cfg'):

        if country is None or country == 'brazil':
            self.country = 455819
            self.settingsFilename = settings_filename
            self.__readConfig()
            #consumer key, consumer secret
            self.auth = tweepy.OAuthHandler(self.consumer_key, self.consumer_secret_key)
            #access token, access token secret
            self.auth.set_access_token(self.access_token, self.access_secret_token)
            #not stream
            self.api = tweepy.API(self.auth)
            self.trends = None

    def __readConfig(self):
        try:
            config = configparser.ConfigParser()
            config.read(self.settingsFilename)
            self.consumer_key = config.get('twitter', 'consumer_key')
            self.consumer_secret_key = config.get('twitter', 'consumer_secret_key')
            self.access_token = config.get('twitter', 'access_token')
            self.access_secret_token = config.get('twitter', 'access_secret_token')
        except configparser.NoSectionError:
            sys.stderr.write("Could not open %s\n" % self.settingsFilename)
            sys.stderr.write("Exiting...\n")
            sys.exit(1)

    def printTrends(self):
        self.trends = self.api.trends_place(self.country)

        for trendsList in self.trends:
            for trend in trendsList['trends']:
                print(trend['name'])


    def searchTweets(self, max_tweets=100, query=None):
        if query is None:
            print("Must define \'query\'!")
            sys.exit(1)
        else:
            #for tweet in tweepy.Cursor(api.search, q=('"good book"'), since='2014-09-16', until='2014-09-17').items(5):
            return [status._json for status in tweepy.Cursor(self.api.search, q=query, include_entities=True).items(max_tweets)]


class MalwareStreamListener(tweepy.StreamListener):
    domainDict = {}
    domainFile = open("data/top-1m.csv", "r")
    lines = domainFile.readlines()
    total_stored_tweets = 0
    client = pymongo.MongoClient("localhost", 27017)
    db = client.dbtesting

    #set BD
    #uri = "mongodb://127.0.0.1/"
    #db = pymongo.MongoClient(uri).dbtesting

    for line in lines:
        line = line.rsplit()
        line = line[0]
        #print(line)
        domainDict[str(line.split(',')[0])] = line.split(',')[1:][0]

    domainFile.close()

    def __init__(self):
        self.api = tweepy.API(createAuth())

        super(tweepy.StreamListener, self).__init__()

    def on_status(self, status):
        #print("Status: ", status.text, "\n")

        data ={}
        data['text'] = status.text
        data['created_at'] = status.created_at
        data['geo'] = status.geo
        data['source'] = status.source
        data['screen_name'] = status.author.screen_name
        data['author_id'] = status.author.id
        data['tweet_id'] = status.id
        data['location'] = status.user.location

        #print(data)
        # #urls is a list of lists
        URLList= re.findall(r'http://[a-zA-Z0-9\.\/\?&=_]+', data['text'])
        if URLList: #not empty
            #print(data)
            self._put_on_db(data)
            print("Inserted: %d" % MalwareStreamListener.total_stored_tweets)


        # #urls is a list of lists
        # URLList= re.findall(r'http://[a-zA-Z0-9\.\/\?&=_]+', data['text'])
        # if URLList: #not empty
        #     for url in URLList:
        #         print("---------------")
        #         print(url)
        #         try:
        #             url = requests.head(url, allow_redirects=True).url
        #             print(url)
        #             if self.searchOnDomains(url):
        #                 print(str(url), " is on the list => safe!")
        #             else:
        #                 print(str(url), " is not on the list => it can be malicious!")
        #
        #         except requests.exceptions.ConnectionError:
        #             print(" -> it is not shortned!")


    def _put_on_db(self, data):
        #print("insert...")
        MalwareStreamListener.db.tweets.insert(data)
        MalwareStreamListener.total_stored_tweets += 1
        # try:
        #     MalwareStreamListener.db.tweets.insert(data)
        #     MalwareStreamListener.total_stored_tweets += 1
        #     print("foi")
        # except:
        #     sys.stderr.write("BD on inserting...\n", sys.exc_info()[0])

    def searchOnDomains(self, url):

        domain = str(urlparse.urljoin(url, "/")[7:-1])
        if domain.startswith("/"):  #http or https
            domain = domain[1:]
        if domain.startswith("www."):
            domain = domain[4:]

        ret = domain in MalwareStreamListener.domainDict.values()
        return ret


if __name__ == "__main__":
    if len(sys.argv) != 5 and len(sys.argv) != 2:
        sys.stderr.write("""
        Usage:
       ./%s -m stream|history -t <#trending_topic> | -l (list trends)
        \n""" % sys.argv[0])
        sys.exit(1)

    #just list trending topics
    if len(sys.argv) == 2:
        auth = createAuth()
        trendsList = getTrends(auth, 455819)
        print("Listing trending topics for location 455819: ")
        counter = 1
        for trend in trendsList:
            print("%d - %s" % (counter, trend))
            counter += 1
        sys.exit(0)

    #argc = 5 => strem mode
    if sys.argv[2] == 'stream':
        auth = createAuth()
        mc = tweepy.streaming.Stream(auth, MalwareStreamListener())

    auth = createAuth()
    trendsList = getTrends(auth, 455819)

    while True:
        try:
            print("Streaming mode for trending topic: " + trendsList[int(sys.argv[4])-1])
            mc.filter(track=[trendsList[int(sys.argv[4])-1]])
        except requests.packages.urllib3.exceptions.ProtocolError:
            continue

